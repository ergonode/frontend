/*
 * Copyright Â© Bold Brand Commerce Sp. z o.o. All rights reserved.
 * See LICENSE for license details.
 */
<template>
    <div
        :class="['layout-element', draggableClasses]"
        :draggable="isDraggingEnabled && !disabled"
        @dragstart="onDragStart"
        @dragend="onDragEnd">
        <slot name="content" />
        <div
            v-if="!disabled"
            class="layout-element__resizer"
            @mousedown="initResizeDrag" />
    </div>
</template>

<script>
import { mapState, mapActions } from 'vuex';
import {
    getHighlightingPositions,
    getHighlightingLayoutDropPositions,
    getMaxRowForGivenColumn,
    getMaxColumnForGivenRow,
    getRowBasedOnHeight,
    getColumnBasedOnWidth,
} from '~/model/template_designer/layout/LayoutCalculations';
import {
    addGhostElementToDraggableLayer,
    updateGhostElementWidth,
    updateGhostElementHeight,
    removeGhostElementFromDraggableLayer,
} from '~/model/template_designer/layout/GhostElement';
import {
    addLayoutElementCopyToDocumentBody,
    removeLayoutElementCopyFromDocumentBody,
} from '~/model/template_designer/layout/LayoutElementCopy';
import { DRAGGED_ELEMENT } from '~/defaults/grid';

export default {
    name: 'LayoutElement',
    props: {
        index: {
            type: Number,
            required: true,
        },
        disabled: {
            type: Boolean,
            required: true,
        },
        element: {
            type: Object,
            required: true,
        },
        columnsNumber: {
            type: Number,
            required: true,
        },
        rowsNumber: {
            type: Number,
            required: true,
        },
    },
    data() {
        return {
            isDraggingEnabled: true,
            startX: 0,
            startY: 0,
            startWidth: 0,
            startHeight: 0,
            minWidth: 0,
            minHeight: 0,
            maxWidth: 0,
            maxHeight: 0,
            newWidth: 0,
            newHeight: 0,
            actualElementRow: 0,
            actualElementColumn: 0,
            highlightingPositions: [],
            elementsGap: 16,
            isDragged: false,
        };
    },
    computed: {
        ...mapState('templateDesigner', {
            layoutElements: (state) => state.layoutElements,
        }),
        ...mapState('draggable', {
            draggedElement: (state) => state.draggedElement,
        }),
        draggableClasses() {
            return {
                'layout-element--dragged': this.isDragged,
                'layout-element--resized': !this.isDraggingEnabled,
                'layout-element--disabled': this.disabled,
            };
        },
    },
    methods: {
        ...mapActions('templateDesigner', [
            'updateLayoutElementBounds',
            'removeLayoutElementAtIndex',
        ]),
        ...mapActions('draggable', [
            'setDraggedElement',
            'setDraggableState',
        ]),
        onDragStart(event) {
            const { id, width, height } = this.element;

            this.setDraggedElement({ ...this.element, index: this.index });
            this.setDraggableState({ propName: 'draggedElementOnGrid', value: DRAGGED_ELEMENT.TEMPLATE });
            window.requestAnimationFrame(() => { this.isDragged = true; });
            addLayoutElementCopyToDocumentBody(event);
            this.highlightingPositions = getHighlightingLayoutDropPositions({
                draggedElWidth: width,
                draggedElHeight: height,
                layoutWidth: this.columnsNumber,
                layoutHeight: this.rowsNumber,
                layoutElements: this.layoutElements.filter((el) => el.id !== id),
            });

            this.$emit('highlightedPositionChange', this.highlightingPositions);
        },
        onDragEnd(event) {
            let xPos = null;
            let yPos = null;

            // Firefox does not support pageX, pageY...
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
                xPos = event.screenX;
                yPos = event.screenY;
            } else {
                xPos = event.pageX;
                yPos = event.pageY;
            }

            const elementBelowMouse = document.elementFromPoint(xPos, yPos);
            const isTrashBelowMouse = elementBelowMouse && elementBelowMouse.className === 'trash-can';

            if (isTrashBelowMouse) {
                this.removeLayoutElementAtIndex(this.index);
                this.setDraggableState({ propName: 'draggedElementOnGrid', value: null });
            } else {
                this.isDragged = false;
            }

            this.highlightingPositions = [];
            this.setDraggedElement();
            removeLayoutElementCopyFromDocumentBody(event);

            this.$emit('highlightedPositionChange', []);
        },
        initResizeDrag(event) {
            this.highlightingPositions = getHighlightingPositions(
                this.element,
                this.layoutElements,
            );

            this.blockOtherInteractionsOnResizeEvent();
            this.initActualElementNormalizedBoundary();
            this.initElementNormalizedBoundary();
            this.initMousePosition(event);
            this.initElementBoundary();
            this.initElementStyleForResizeState();

            addGhostElementToDraggableLayer({
                top: this.$el.offsetTop,
                left: this.$el.offsetLeft,
                width: this.startWidth,
                height: this.startHeight,
            });

            this.minWidth = this.getElementMinWidth();
            this.minHeight = this.getElementMinHeight();

            this.addEventListenersForResizeState();

            this.$emit('highlightedPositionChange', this.highlightingPositions);
        },
        doResizeDrag(event) {
            const { pageX, pageY } = event;
            const width = this.getElementWidthBasedOnMouseXPosition(pageX);
            const height = this.getElementHeightBasedOnMouseYPosition(pageY);

            this.updateElementWidth(width);
            this.updateElementHeight(height);
        },
        stopResizeDrag() {
            this.updateLayoutElementBounds({
                index: this.index,
                width: this.newWidth,
                height: this.newHeight,
            });

            this.resetElementStyleForEndResizeInteraction();
            this.resetDataForEndResizeInteraction();

            removeGhostElementFromDraggableLayer();
            this.removeEventListenersForResizeState();

            this.$emit('highlightedPositionChange', []);
        },
        getElementWidthBasedOnMouseXPosition(xPos) {
            return this.startWidth + xPos - this.startX;
        },
        getElementHeightBasedOnMouseYPosition(yPos) {
            return this.startHeight + yPos - this.startY;
        },
        getElementMinWidth() {
            const { width } = this.element;
            return (this.startWidth - (this.elementsGap * (width - 1))) / width;
        },
        getElementMinHeight() {
            const { height } = this.element;
            return (this.startHeight - (this.elementsGap * (height - 1))) / height;
        },
        getElementMaxWidth(maxWidth) {
            const { column } = this.element;
            const columnsNumberToFill = maxWidth - (column - 1);
            const elementGapsNumber = columnsNumberToFill - 1;

            return (this.minWidth * columnsNumberToFill) + (elementGapsNumber * this.elementsGap);
        },
        getElementMaxHeight(maxHeight) {
            return (this.minHeight * maxHeight) + ((maxHeight - 1) * this.elementsGap);
        },
        updateElementWidth(width) {
            const { column } = this.element;
            const columnBellowMouse = getColumnBasedOnWidth(width, this.minWidth, column);
            const maxColumn = getMaxColumnForGivenRow(
                this.actualElementRow,
                this.highlightingPositions,
            );
            const elWidth = 1 + maxColumn - column;
            this.maxWidth = this.getElementMaxWidth(elWidth);

            if (width <= this.maxWidth && width >= this.minWidth) {
                this.newWidth = columnBellowMouse - column + 1;

                if (columnBellowMouse !== this.actualElementColumn) {
                    const gapsValue = this.elementsGap * (this.newWidth - 1);
                    const ghostElementWidth = this.minWidth * this.newWidth
                        + gapsValue;

                    updateGhostElementWidth(ghostElementWidth);
                }

                this.$el.style.width = `${width}px`;
                this.actualElementColumn = columnBellowMouse;
            }
        },
        updateElementHeight(height) {
            const { row } = this.element;
            const rowBellowMouse = getRowBasedOnHeight(height, this.minHeight, row);
            const maxRow = getMaxRowForGivenColumn(
                this.actualElementColumn,
                this.highlightingPositions,
            );
            const elHeight = 1 + maxRow - row;
            this.maxHeight = this.getElementMaxHeight(elHeight);

            if (height <= this.maxHeight && height >= this.minHeight) {
                this.newHeight = rowBellowMouse - row + 1;

                if (rowBellowMouse !== this.actualElementRow) {
                    const gapsValue = this.elementsGap * (this.newHeight - 1);
                    const ghostElementHeight = this.minHeight * this.newHeight
                        + gapsValue;

                    updateGhostElementHeight(ghostElementHeight);
                }

                this.$el.style.height = `${height}px`;
                this.actualElementRow = rowBellowMouse;

                this.$emit('resizingElMaxRow', this.newHeight + row);
            }
        },
        addEventListenersForResizeState() {
            document.documentElement.addEventListener(
                'mousemove',
                this.doResizeDrag,
                false,
            );
            document.documentElement.addEventListener(
                'mouseup',
                this.stopResizeDrag,
                false,
            );
        },
        removeEventListenersForResizeState() {
            document.documentElement.removeEventListener(
                'mousemove',
                this.doResizeDrag,
                false,
            );
            document.documentElement.removeEventListener(
                'mouseup',
                this.stopResizeDrag,
                false,
            );
        },
        blockOtherInteractionsOnResizeEvent() {
            this.isDraggingEnabled = false;
        },
        initMousePosition({ pageX, pageY }) {
            this.startX = pageX;
            this.startY = pageY;
        },
        initActualElementNormalizedBoundary() {
            const { row, column } = this.element;

            this.actualElementRow = row;
            this.actualElementColumn = column;
        },
        initElementBoundary() {
            const {
                width: elementWidth,
                height: elementHeight,
            } = this.$el.getBoundingClientRect();

            this.startWidth = parseInt(elementWidth, 10);
            this.startHeight = parseInt(elementHeight, 10);
        },
        initElementNormalizedBoundary() {
            const { width, height } = this.element;

            this.newWidth = width;
            this.newHeight = height;
        },
        initElementStyleForResizeState() {
            this.$el.style.width = `${this.startWidth}px`;
            this.$el.style.height = `${this.startHeight}px`;
        },
        resetElementStyleForEndResizeInteraction() {
            this.$el.style.width = null;
            this.$el.style.height = null;
        },
        resetDataForEndResizeInteraction() {
            this.isDraggingEnabled = true;
            this.highlightingPositions = [];
        },
    },
};
</script>

<style lang="scss" scoped>
    .layout-element {
        position: relative;
        z-index: $Z_INDEX_UNSET;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        border: $BORDER_1_GREY;
        margin: 8px;
        box-sizing: border-box;
        background-color: $WHITESMOKE;
        user-select: none;
        cursor: grab;

        &:hover:not(&--resized):not(&--disabled) {
            border: unset;
            box-shadow: $ELEVATOR_2_DP;
        }

        &__resizer {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 10px;
            height: 10px;
            cursor: se-resize;
        }

        &--dragged {
            visibility: hidden;
        }

        &--resized {
            position: absolute;
            z-index: 5;
            border: 2px solid $GREEN;
        }

        &--disabled {
            cursor: not-allowed;
        }
    }
</style>
